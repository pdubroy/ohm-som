SOM {
    Classdef =
      identifier equal Superclass InstanceFields Method* (separator ClassFields Method*)? endTerm

    Superclass = identifier? newTerm

    InstanceFields = (or identifier* or)?

    ClassFields = (or identifier* or)?

    Method = Pattern equal (primitive | MethodBlock)

    Pattern = UnaryPattern | BinaryPattern | KeywordPattern

    UnaryPattern = unarySelector

    BinaryPattern = binarySelector identifier

    KeywordPattern = (keyword identifier)+

    MethodBlock = newTerm BlockContents? endTerm

    BlockContents = (or LocalDefs or)? BlockBody

    LocalDefs = identifier*

    BlockBody =
      | exit Result  -- return
      | Expression ( period BlockBody? )? -- rec

    Result = Expression period?

    Expression = Assignation | Evaluation

    Assignation = Assignments Evaluation

    Assignments = Assignment+

    Assignment = identifier assign

    Evaluation = Primary Messages?

    Primary = identifier | NestedTerm | NestedBlock | Literal

    // TODO(pdubroy): Make this recursive instead?
    Messages =
      | UnaryMessage+ BinaryMessage* KeywordMessage?  -- unaryFirst
      | BinaryMessage+ KeywordMessage?  -- binaryFirst
      | KeywordMessage

    UnaryMessage = unarySelector

    BinaryMessage = binarySelector BinaryOperand

    BinaryOperand = Primary UnaryMessage*

    KeywordMessage = (keyword Formula)+

    Formula = BinaryOperand BinaryMessage*

    NestedTerm = newTerm Expression endTerm

    Literal = LiteralArray | LiteralSymbol | LiteralString | LiteralNumber

    LiteralArray = pound newTerm Literal* endTerm

    LiteralNumber = NegativeDecimal | LiteralDecimal

    LiteralDecimal = LiteralDouble | LiteralInteger

    NegativeDecimal = minus LiteralDecimal

    LiteralInteger = integer

    LiteralDouble = double

    LiteralSymbol = pound (string | selector)

    LiteralString = string

    NestedBlock = newBlock BlockPattern? BlockContents? endBlock

    BlockPattern = BlockArguments or

    BlockArguments = (colon identifier)+

    // Lexical rules

    selector = unarySelector | binarySelector | keywordSelector

    unarySelector = (primitive | identifier) ~colon
    binarySelector = operatorSequence | operator
    keywordSelector = keyword+
    keyword = identifier colon

    comment = quote (~quote any)* quote
    quote = "\""
    space += comment

    identifier = letter idRest*
    idRest = letter | digit | "_"

    primitive = "primitive" ~idRest

    equal = "="

    separator = "----" "-"*

    newTerm = "("
    endTerm = ")"
    or = "|"

    comma = ","
    minus = "-"
    not = "~"
    and = "&"
    star = "*"
    div = "/"
    mod = "\\"
    plus = "+"
    more = ">"
    less = "<"
    at = "@"
    per = "%"

    operator =
      not | and | or | star | div | mod | plus | equal | more | less | comma | at | per | minus
    operatorSequence = operator+

    newBlock = "["
    endBlock = "]"

    colon = ":"
    pound = "#"
    exit = "^"
    period = "."
    assign = ":="

    integer = digit+
    double = digit+ "." digit+

    string = "'" (escapeChar | ~("'" | "\\") any)* "'"

    escapeChar (an escape sequence) =
      | "\\t"  -- tab
      | "\\b"  -- backspace
      | "\\n"  -- lineFeed
      | "\\r"  -- carriageReturn
      | "\\f"  -- formFeed
      | "\\0"  -- null
      | "\\\'"  -- singleQuote
      | "\\\\"  -- backslash
}
