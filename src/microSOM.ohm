SOM {
    Classdef =
        identifier equal Superclass InstanceFields Method* (separator ClassFields Method*)? endTerm

    Superclass =
        identifier? newTerm

    InstanceFields =
        ( or variable* or )?

    ClassFields =
        ( or variable* or )?

    Method = 
       Pattern equal (primitive | MethodBlock)

    Pattern =
        UnaryPattern | BinaryPattern | KeywordPattern

    UnaryPattern = 
        unarySelector

    BinaryPattern =
        binarySelector argument

    KeywordPattern =
        (keyword argument)+

    MethodBlock =
        newTerm BlockContents? endTerm

    unarySelector =
        (primitive | identifier) ~colon

    binarySelector = operatorSequence |
        or | comma | minus | equal | not | and | star | div | mod | plus | more |
        less | at | per

    argument = variable

    BlockContents =
        (or LocalDefs or)? BlockBody

    LocalDefs =
        variable*

    BlockBody =
          exit Result  -- return
        | Expression ( period BlockBody? )? -- rec

    Result =
        Expression period?

    Expression =
        Assignation | Evaluation

    Assignation =
        Assignments Evaluation

    Assignments =
        Assignment+

    Assignment =
        variable assign

    Evaluation =
        Primary Messages?

    Primary =
        variable | NestedTerm | NestedBlock | Literal

    variable = identifier

    // TODO(pdubroy): Make this recursive instead?
    Messages =
        | UnaryMessage+ BinaryMessage* KeywordMessage?  -- unaryFirst
        | BinaryMessage+ KeywordMessage?  -- binaryFirst
        | KeywordMessage

    UnaryMessage =
        unarySelector

    BinaryMessage =
        binarySelector BinaryOperand

    BinaryOperand =
        Primary UnaryMessage*

    KeywordMessage =
        ( keyword Formula )+

    Formula =
        BinaryOperand BinaryMessage*

    NestedTerm =
        newTerm Expression endTerm

    Literal =
        LiteralArray | LiteralSymbol | LiteralString | LiteralNumber

    LiteralArray =
        pound newTerm Literal* endTerm

    LiteralNumber =
        NegativeDecimal | LiteralDecimal

    LiteralDecimal =
        LiteralDouble | LiteralInteger

    NegativeDecimal =
        minus LiteralDecimal

    LiteralInteger =
        integer

    LiteralDouble =
        double

    LiteralSymbol =
        pound ( string | selector )

    LiteralString =
        string

    selector =
        binarySelector | keywordSelector | unarySelector

    keywordSelector =
        keywordSequence | keyword  // TODO(pdubroy): Remove alternation here, 'keyword' is redundant.

    string =
        stString

    NestedBlock =
        newBlock BlockPattern? BlockContents? endBlock

    BlockPattern =
        BlockArguments or

    BlockArguments =
        ( colon argument )+

    // Lexer

    comment = quote (~quote any)* quote
    quote = "\""
    space += comment

    primitive = "primitive"
    identifier = letter (letter | digit | "_")*

    equal = "="

    separator = "----" "-"*

    newTerm = "("
    endTerm = ")"
    or = "|"

    comma = ","
    minus = "-"
    not =   "~"
    and =   "&"
    star =  "*"
    div =   "/"
    mod =   "\\"
    plus =  "+"
    more =  ">"
    less =  "<"
    at =    "@"
    per =   "%"

    operatorSequence = (
        not | and | or | star | div |
        mod | plus | equal | more | less |
        comma | at | per | minus )+

    colon = ":"

    newBlock = "["
    endBlock = "]"

    pound = "#"

    exit = "^"
    period = "."
    assign = ":="

    integer = digit+
    double = digit+ "." digit+
    keyword = identifier colon
    keywordSequence = keyword+
    stString =
        "'"
        (   "\\t"
          | "\\b"
          | "\\n"
          | "\\r"
          | "\\f"
          | "\\0"
          | "\\'"
          | "\\\\"
          | ~("'" | "\\") any
        )*
        "'"
}
