SOM {
/*
    classdef =
        Identifier Equal superclass instanceFields method* ( Separator classFields method* )? endTerm

    superclass =
        Identifier? newTerm

    instanceFields =
        ( or variable* or )?

    classFields =
        ( or variable* or )?
*/

    Method (a method) = 
       Pattern equal (primitive | MethodBlock)

    Pattern (a pattern) =
        KeywordPattern | UnaryPattern | BinaryPattern

    UnaryPattern = 
        unarySelector

    BinaryPattern =
        binarySelector argument

    KeywordPattern =
        (keyword argument)+

    MethodBlock (a method block) =
        newTerm BlockContents? endTerm

    unarySelector =
        primitive | identifier

    binarySelector = operatorSequence |
        or | comma | minus | equal | not | and | star | div | mod | plus | more |
        less | at | per

    argument = variable

    BlockContents =
        (or LocalDefs or)? BlockBody

    LocalDefs =
        variable*

    BlockBody =
          exit Result  -- return
        | Expression ( period BlockBody? )? -- rec

    Result =
        Expression period?

    Expression =
        Assignation | Evaluation

    Assignation =
        Assignments Evaluation

    Assignments =
        Assignment+

    Assignment =
        variable assign

    Evaluation =
        Primary /* Messages? */

    Primary =
        variable /* | nestedTerm | nestedBlock */ | Literal

    variable = identifier
/*
    messages =
          unaryMessage+ binaryMessage* keywordMessage?
        | binaryMessage+ keywordMessage?
        | keywordMessage

    unaryMessage =
        unarySelector

    binaryMessage =
        binarySelector binaryOperand

    binaryOperand =
        primary unaryMessage*

    keywordMessage =
        ( keyword formula )+

    formula =
        binaryOperand binaryMessage*

    nestedTerm =
        newTerm expression endTerm
*/
    Literal =
        /* LiteralArray | LiteralSymbol | */ Literalstring | LiteralNumber
/*
    literalArray =
        Pound newTerm
        literal*
        endTerm
*/
    LiteralNumber =
        NegativeDecimal | LiteralDecimal

    LiteralDecimal =
        LiteralDouble | LiteralInteger

    NegativeDecimal =
        minus LiteralDecimal

    LiteralInteger =
        integer

    LiteralDouble =
        double
/*
    LiteralSymbol =
        Pound ( string | selector )
*/
    Literalstring =
        string
/*
    selector =
        binarySelector | keywordSelector | unarySelector

    keywordSelector =
        Keyword | KeywordSequence
*/
    string =
        stString
/*
    nestedBlock =
        NewBlock blockPattern? blockContents? EndBlock

    blockPattern =
        blockArguments or

    blockArguments =
        ( Colon argument )+

    // Lexer

    Comment =   '"' ~["]* '"' -> skip
    Whitespace : [ \t\r\n]+ -> skip 
*/
    primitive = "primitive"
    identifier = letter (letter | digit | "_")*

    equal = "="
/*
    Separator = '----' '-'*
*/
    newTerm = "("
    endTerm = ")"
    or = "|"

    comma = ","
    minus = "-"
    not =   "~"
    and =   "&"
    star =  "*"
    div =   "/"
    mod =   "\\"
    plus =  "+"
    more =  ">"
    less =  "<"
    at =    "@"
    per =   "%"

    operatorSequence = (
        not | and | or | star | div |
        mod | plus | equal | more | less |
        comma | at | per | minus )+

    colon = ":"
/*
    NewBlock = '['
    EndBlock = ']'

    Pound =  '#'
*/
    exit = "^"
    period = "."
    assign = ":="

    integer = digit+
    double = digit+ "." digit+
    keyword = identifier colon
/*
    KeywordSequence = Keyword+
*/
    stString =
        "'"
        (   "\\t"
          | "\\b"
          | "\\n"
          | "\\r"
          | "\\f"
          | "\\0"
          | "\\'"
          | "\\\\"
          | ~("'" | "\\") any
        )*
        "'"
}