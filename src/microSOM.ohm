SOM {
/*
    classdef:
        Identifier Equal superclass instanceFields method* ( Separator classFields method* )? endTerm

    superclass:
        Identifier? newTerm

    instanceFields:
        ( or variable* or )?

    classFields:
        ( or variable* or )?
*/

    Method (a method) = 
       Pattern equal (primitive | MethodBlock)

    Pattern (a pattern) =
        KeywordPattern | UnaryPattern /* | BinaryPattern */

    UnaryPattern = 
        unarySelector

/*
    BinaryPattern =
        binarySelector argument
*/

    KeywordPattern =
        (keyword argument)+

    MethodBlock (a method block) =
        newTerm /* BlockContents? */ endTerm

    unarySelector =
        primitive | identifier

/*
    binarySelector:
        or | Comma | Minus | Equal | Not | And | Star | Div | Mod | Plus | More |
        Less | At | Per | OperatorSequence
*/

    argument =
        variable
/*
    BlockContents =
        (or LocalDefs or)? BlockBody

    LocalDefs =
        variable*

    BlockBody =
          Exit result
        | expression ( Period blockBody? )?
    result:
        expression Period?

    expression:
        assignation | evaluation

    assignation:
        assignments evaluation

    assignments:
        assignment+

    assignment:
        variable Assign

    evaluation:
        primary messages?

    primary:
        variable | nestedTerm | nestedBlock | literal
*/
    variable =
        identifier
/*
    messages:
          unaryMessage+ binaryMessage* keywordMessage?
        | binaryMessage+ keywordMessage?
        | keywordMessage

    unaryMessage:
        unarySelector

    binaryMessage:
        binarySelector binaryOperand

    binaryOperand:
        primary unaryMessage*

    keywordMessage:
        ( keyword formula )+

    formula:
        binaryOperand binaryMessage*

    nestedTerm:
        newTerm expression endTerm

    literal:
        literalArray | literalSymbol | literalString | literalNumber

    literalArray:
        Pound newTerm
        literal*
        endTerm

    literalNumber:
        negativeDecimal | literalDecimal

    literalDecimal:
        literalInteger | literalDouble

    negativeDecimal:
        Minus literalDecimal

    literalInteger:
        Integer

    literalDouble:
        Double

    literalSymbol:
        Pound ( string | selector )

    literalString:
        string

    selector:
        binarySelector | keywordSelector | unarySelector

    keywordSelector:
        Keyword | KeywordSequence

    string:
        STString

    nestedBlock:
        NewBlock blockPattern? blockContents? EndBlock

    blockPattern:
        blockArguments or

    blockArguments:
        ( Colon argument )+

    // Lexer

    Comment:   '"' ~["]* '"' -> skip
    Whitespace : [ \t\r\n]+ -> skip 
*/
    primitive = "primitive"
    identifier = letter (letter | digit | "_")*

    equal = "="
/*
    Separator: '----' '-'*
*/
    newTerm = "("
    endTerm = ")"
    or = "|"

/*
    Comma: ','
    Minus: '-'
    Not:   '~'
    And:   '&'
    Star:  '*'
    Div:   '/'
    Mod:   '\\'
    Plus:  '+'
    More:  '>'
    Less:  '<'
    At:    '@'
    Per:   '%'

    OperatorSequence: (
        Not | And | or | Star | Div |
        Mod | Plus | Equal | More | Less |
        Comma | At | Per | Minus )+
*/
    colon = ":"
/*
    NewBlock: '['
    EndBlock: ']'

    Pound:  '#'
*/
    exit = "^"
/*
    Period: '.'
    Assign: ':='

    Integer: [0-9]+
    Double: [0-9]+ '.' [0-9]+
*/
    keyword = identifier colon
/*
    KeywordSequence: Keyword+

    STString:
        '\''
        (   '\\t'
          | '\\b'
          | '\\n'
          | '\\r'
          | '\\f'
          | '\\0'
          | '\\\''
          | '\\\\'
          |  ~('\''| '\\')
        )*
        '\''
*/
}